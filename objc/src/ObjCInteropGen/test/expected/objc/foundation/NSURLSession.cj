// Generated by ObjCInteropGen

package objc.foundation

import interoplib.objc.*
import objc.lang.*

@ObjCMirror
public interface NSURLSessionDelegate <: NSObjectProtocol {
    @ObjCOptional
    @ForeignName["URLSession:didBecomeInvalidWithError:"] func URLSessionDidBecomeInvalidWithError(session: NSURLSession, error: ?NSError): Unit
    @ObjCOptional
    @ForeignName["URLSession:didReceiveChallenge:completionHandler:"] func URLSessionDidReceiveChallengeCompletionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: ObjCBlock<(Int32 /*NSURLSessionAuthChallengeDisposition*/, NSURLCredential) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSessionDidFinishEventsForBackgroundURLSession:"] func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): Unit
}

@ObjCMirror
public interface NSURLSessionTaskDelegate <: NSURLSessionDelegate {
    @ObjCOptional
    @ForeignName["URLSession:didCreateTask:"] func URLSessionDidCreateTask(session: NSURLSession, task: NSURLSessionTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:willBeginDelayedRequest:completionHandler:"] func URLSessionTaskWillBeginDelayedRequestCompletionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: ObjCBlock<(Int32 /*NSURLSessionDelayedRequestDisposition*/, NSURLRequest) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:taskIsWaitingForConnectivity:"] func URLSessionTaskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:"] func URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: ObjCBlock<(NSURLRequest) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:didReceiveChallenge:completionHandler:"] func URLSessionTaskDidReceiveChallengeCompletionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: ObjCBlock<(Int32 /*NSURLSessionAuthChallengeDisposition*/, NSURLCredential) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:needNewBodyStream:"] func URLSessionTaskNeedNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: ObjCBlock<(NSInputStream) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:needNewBodyStreamFromOffset:completionHandler:"] func URLSessionTaskNeedNewBodyStreamFromOffsetCompletionHandler(session: NSURLSession, task: NSURLSessionTask, offset: int64_t, completionHandler: ObjCBlock<(NSInputStream) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:"] func URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: int64_t, totalBytesSent: int64_t, totalBytesExpectedToSend: int64_t): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:didReceiveInformationalResponse:"] func URLSessionTaskDidReceiveInformationalResponse(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:didFinishCollectingMetrics:"] func URLSessionTaskDidFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): Unit
    @ObjCOptional
    @ForeignName["URLSession:task:didCompleteWithError:"] func URLSessionTaskDidCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: ?NSError): Unit
}

@ObjCMirror
public open class NSURLSession <: NSObject {
    public static prop sharedSession: NSURLSession
    @ForeignName["sessionWithConfiguration:"] public static func sessionWithConfiguration(configuration: NSURLSessionConfiguration): NSURLSession
    @ForeignName["sessionWithConfiguration:delegate:delegateQueue:"] public static func sessionWithConfigurationDelegateDelegateQueue(configuration: NSURLSessionConfiguration, delegate: ?NSURLSessionDelegate, queue: ?NSOperationQueue): NSURLSession
    public open prop delegateQueue: NSOperationQueue
    public open prop delegate: ?NSURLSessionDelegate
    public open prop configuration: NSURLSessionConfiguration
    public open mut prop sessionDescription: ?NSString
    public open func finishTasksAndInvalidate(): Unit
    public open func invalidateAndCancel(): Unit
    @ForeignName["resetWithCompletionHandler:"] public open func resetWithCompletionHandler(completionHandler: ObjCBlock<() -> Unit>): Unit
    @ForeignName["flushWithCompletionHandler:"] public open func flushWithCompletionHandler(completionHandler: ObjCBlock<() -> Unit>): Unit
    @ForeignName["getTasksWithCompletionHandler:"] public open func getTasksWithCompletionHandler(completionHandler: ObjCBlock<(NSArray/*<NSURLSessionDataTask>*/, NSArray/*<NSURLSessionUploadTask>*/, NSArray/*<NSURLSessionDownloadTask>*/) -> Unit>): Unit
    @ForeignName["getAllTasksWithCompletionHandler:"] public open func getAllTasksWithCompletionHandler(completionHandler: ObjCBlock<(NSArray/*<NSURLSessionTask>*/) -> Unit>): Unit
    @ForeignName["dataTaskWithRequest:"] public open func dataTaskWithRequest(request: NSURLRequest): NSURLSessionDataTask
    @ForeignName["dataTaskWithURL:"] public open func dataTaskWithURL(url: NSURL): NSURLSessionDataTask
    @ForeignName["uploadTaskWithRequest:fromFile:"] public open func uploadTaskWithRequestFromFile(request: NSURLRequest, fileURL: NSURL): NSURLSessionUploadTask
    @ForeignName["uploadTaskWithRequest:fromData:"] public open func uploadTaskWithRequestFromData(request: NSURLRequest, bodyData: NSData): NSURLSessionUploadTask
    @ForeignName["uploadTaskWithResumeData:"] public open func uploadTaskWithResumeData(resumeData: NSData): NSURLSessionUploadTask
    @ForeignName["uploadTaskWithStreamedRequest:"] public open func uploadTaskWithStreamedRequest(request: NSURLRequest): NSURLSessionUploadTask
    @ForeignName["downloadTaskWithRequest:"] public open func downloadTaskWithRequest(request: NSURLRequest): NSURLSessionDownloadTask
    @ForeignName["downloadTaskWithURL:"] public open func downloadTaskWithURL(url: NSURL): NSURLSessionDownloadTask
    @ForeignName["downloadTaskWithResumeData:"] public open func downloadTaskWithResumeData(resumeData: NSData): NSURLSessionDownloadTask
    @ForeignName["streamTaskWithHostName:port:"] public open func streamTaskWithHostNamePort(hostname: NSString, port: NSInteger): NSURLSessionStreamTask
    @ForeignName["streamTaskWithNetService:"] public open func streamTaskWithNetService(service: NSNetService): NSURLSessionStreamTask
    @ForeignName["webSocketTaskWithURL:"] public open func webSocketTaskWithURL(url: NSURL): NSURLSessionWebSocketTask
    @ForeignName["webSocketTaskWithURL:protocols:"] public open func webSocketTaskWithURLProtocols(url: NSURL, protocols: NSArray/*<NSString>*/): NSURLSessionWebSocketTask
    @ForeignName["webSocketTaskWithRequest:"] public open func webSocketTaskWithRequest(request: NSURLRequest): NSURLSessionWebSocketTask
    public init()
    public static func new(): NSURLSession
    @ForeignName["dataTaskWithRequest:completionHandler:"] public open func dataTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: ObjCBlock<(NSData, NSURLResponse, NSError) -> Unit>): NSURLSessionDataTask
    @ForeignName["dataTaskWithURL:completionHandler:"] public open func dataTaskWithURLCompletionHandler(url: NSURL, completionHandler: ObjCBlock<(NSData, NSURLResponse, NSError) -> Unit>): NSURLSessionDataTask
    @ForeignName["uploadTaskWithRequest:fromFile:completionHandler:"] public open func uploadTaskWithRequestFromFileCompletionHandler(request: NSURLRequest, fileURL: NSURL, completionHandler: ObjCBlock<(NSData, NSURLResponse, NSError) -> Unit>): NSURLSessionUploadTask
    @ForeignName["uploadTaskWithRequest:fromData:completionHandler:"] public open func uploadTaskWithRequestFromDataCompletionHandler(request: NSURLRequest, bodyData: ?NSData, completionHandler: ObjCBlock<(NSData, NSURLResponse, NSError) -> Unit>): NSURLSessionUploadTask
    @ForeignName["uploadTaskWithResumeData:completionHandler:"] public open func uploadTaskWithResumeDataCompletionHandler(resumeData: NSData, completionHandler: ObjCBlock<(NSData, NSURLResponse, NSError) -> Unit>): NSURLSessionUploadTask
    @ForeignName["downloadTaskWithRequest:completionHandler:"] public open func downloadTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: ObjCBlock<(NSURL, NSURLResponse, NSError) -> Unit>): NSURLSessionDownloadTask
    @ForeignName["downloadTaskWithURL:completionHandler:"] public open func downloadTaskWithURLCompletionHandler(url: NSURL, completionHandler: ObjCBlock<(NSURL, NSURLResponse, NSError) -> Unit>): NSURLSessionDownloadTask
    @ForeignName["downloadTaskWithResumeData:completionHandler:"] public open func downloadTaskWithResumeDataCompletionHandler(resumeData: NSData, completionHandler: ObjCBlock<(NSURL, NSURLResponse, NSError) -> Unit>): NSURLSessionDownloadTask
}

public abstract sealed class NSURLSessionTaskState {
    public static const NSURLSessionTaskStateRunning: NSInteger = 0
    public static const NSURLSessionTaskStateSuspended: NSInteger = 1
    public static const NSURLSessionTaskStateCanceling: NSInteger = 2
    public static const NSURLSessionTaskStateCompleted: NSInteger = 3
}

@ObjCMirror
public open class NSURLSessionTask <: NSObject & NSCopying & NSProgressReporting {
    public open prop taskIdentifier: NSUInteger
    public open prop originalRequest: ?NSURLRequest
    public open prop currentRequest: ?NSURLRequest
    public open prop response: ?NSURLResponse
    public open mut prop delegate: ?NSURLSessionTaskDelegate
    public open mut prop earliestBeginDate: ?NSDate
    public open mut prop countOfBytesClientExpectsToSend: int64_t
    public open mut prop countOfBytesClientExpectsToReceive: int64_t
    public open prop countOfBytesSent: int64_t
    public open prop countOfBytesReceived: int64_t
    public open prop countOfBytesExpectedToSend: int64_t
    public open prop countOfBytesExpectedToReceive: int64_t
    public open mut prop taskDescription: ?NSString
    public open func cancel(): Unit
    public open prop state: Int32 /*NSURLSessionTaskState*/
    public open prop error: ?NSError
    public open func suspend(): Unit
    public open func `resume`(): Unit
    public open mut prop priority: Float32
    public open mut prop prefersIncrementalDelivery: Bool
    public init()
    public static func new(): NSURLSessionTask
}

@ObjCMirror
public open class NSURLSessionDataTask <: NSURLSessionTask {
    public init()
    public static func new(): NSURLSessionDataTask
}

@ObjCMirror
public open class NSURLSessionUploadTask <: NSURLSessionDataTask {
    public init()
    public static func new(): NSURLSessionUploadTask
    @ForeignName["cancelByProducingResumeData:"] public open func cancelByProducingResumeData(completionHandler: ObjCBlock<(NSData) -> Unit>): Unit
}

@ObjCMirror
public open class NSURLSessionDownloadTask <: NSURLSessionTask {
    @ForeignName["cancelByProducingResumeData:"] public open func cancelByProducingResumeData(completionHandler: ObjCBlock<(NSData) -> Unit>): Unit
    public init()
    public static func new(): NSURLSessionDownloadTask
}

@ObjCMirror
public open class NSURLSessionStreamTask <: NSURLSessionTask {
    @ForeignName["readDataOfMinLength:maxLength:timeout:completionHandler:"] public open func readDataOfMinLengthMaxLengthTimeoutCompletionHandler(minBytes: NSUInteger, maxBytes: NSUInteger, timeout: NSTimeInterval, completionHandler: ObjCBlock<(NSData, Bool, NSError) -> Unit>): Unit
    @ForeignName["writeData:timeout:completionHandler:"] public open func writeDataTimeoutCompletionHandler(data: NSData, timeout: NSTimeInterval, completionHandler: ObjCBlock<(NSError) -> Unit>): Unit
    public open func captureStreams(): Unit
    public open func closeWrite(): Unit
    public open func closeRead(): Unit
    public open func startSecureConnection(): Unit
    public open func stopSecureConnection(): Unit
    public init()
    public static func new(): NSURLSessionStreamTask
}

public abstract sealed class NSURLSessionWebSocketMessageType {
    public static const NSURLSessionWebSocketMessageTypeData: NSInteger = 0
    public static const NSURLSessionWebSocketMessageTypeString: NSInteger = 1
}

@ObjCMirror
public open class NSURLSessionWebSocketMessage <: NSObject {
    @ForeignName["initWithData:"] public init(data: NSData)
    @ForeignName["initWithString:"] public init(string: NSString)
    public open prop `type`: Int32 /*NSURLSessionWebSocketMessageType*/
    public open prop data: ?NSData
    public open prop string: ?NSString
}

public abstract sealed class NSURLSessionWebSocketCloseCode {
    public static const NSURLSessionWebSocketCloseCodeInvalid: NSInteger = 0
    public static const NSURLSessionWebSocketCloseCodeNormalClosure: NSInteger = 1000
    public static const NSURLSessionWebSocketCloseCodeGoingAway: NSInteger = 1001
    public static const NSURLSessionWebSocketCloseCodeProtocolError: NSInteger = 1002
    public static const NSURLSessionWebSocketCloseCodeUnsupportedData: NSInteger = 1003
    public static const NSURLSessionWebSocketCloseCodeNoStatusReceived: NSInteger = 1005
    public static const NSURLSessionWebSocketCloseCodeAbnormalClosure: NSInteger = 1006
    public static const NSURLSessionWebSocketCloseCodeInvalidFramePayloadData: NSInteger = 1007
    public static const NSURLSessionWebSocketCloseCodePolicyViolation: NSInteger = 1008
    public static const NSURLSessionWebSocketCloseCodeMessageTooBig: NSInteger = 1009
    public static const NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing: NSInteger = 1010
    public static const NSURLSessionWebSocketCloseCodeInternalServerError: NSInteger = 1011
    public static const NSURLSessionWebSocketCloseCodeTLSHandshakeFailure: NSInteger = 1015
}

@ObjCMirror
public open class NSURLSessionWebSocketTask <: NSURLSessionTask {
    @ForeignName["sendMessage:completionHandler:"] public open func sendMessageCompletionHandler(message: NSURLSessionWebSocketMessage, completionHandler: ObjCBlock<(NSError) -> Unit>): Unit
    @ForeignName["receiveMessageWithCompletionHandler:"] public open func receiveMessageWithCompletionHandler(completionHandler: ObjCBlock<(NSURLSessionWebSocketMessage, NSError) -> Unit>): Unit
    @ForeignName["sendPingWithPongReceiveHandler:"] public open func sendPingWithPongReceiveHandler(pongReceiveHandler: ObjCBlock<(NSError) -> Unit>): Unit
    @ForeignName["cancelWithCloseCode:reason:"] public open func cancelWithCloseCodeReason(closeCode: Int32 /*NSURLSessionWebSocketCloseCode*/, reason: ?NSData): Unit
    public open mut prop maximumMessageSize: NSInteger
    public open prop closeCode: Int32 /*NSURLSessionWebSocketCloseCode*/
    public open prop closeReason: ?NSData
}

public abstract sealed class NSURLSessionMultipathServiceType {
    public static const NSURLSessionMultipathServiceTypeNone: NSInteger = 0
    public static const NSURLSessionMultipathServiceTypeHandover: NSInteger = 1
    public static const NSURLSessionMultipathServiceTypeInteractive: NSInteger = 2
    public static const NSURLSessionMultipathServiceTypeAggregate: NSInteger = 3
}

@ObjCMirror
public open class NSURLSessionConfiguration <: NSObject & NSCopying {
    public static prop defaultSessionConfiguration: NSURLSessionConfiguration
    public static prop ephemeralSessionConfiguration: NSURLSessionConfiguration
    @ForeignName["backgroundSessionConfigurationWithIdentifier:"] public static func backgroundSessionConfigurationWithIdentifier(identifier: NSString): NSURLSessionConfiguration
    public open prop identifier: ?NSString
    public open mut prop requestCachePolicy: Int32 /*NSURLRequestCachePolicy*/
    public open mut prop timeoutIntervalForRequest: NSTimeInterval
    public open mut prop timeoutIntervalForResource: NSTimeInterval
    public open mut prop networkServiceType: Int32 /*NSURLRequestNetworkServiceType*/
    public open mut prop allowsCellularAccess: Bool
    public open mut prop allowsExpensiveNetworkAccess: Bool
    public open mut prop allowsConstrainedNetworkAccess: Bool
    public open mut prop requiresDNSSECValidation: Bool
    public open mut prop waitsForConnectivity: Bool
    public open mut prop isDiscretionary: Bool
    public open mut prop sharedContainerIdentifier: ?NSString
    public open mut prop sessionSendsLaunchEvents: Bool
    public open mut prop connectionProxyDictionary: ?NSDictionary/*<KeyType, ObjectType>*/
    public open mut prop TLSMinimumSupportedProtocol: Int32 /*SSLProtocol*/
    public open mut prop TLSMaximumSupportedProtocol: Int32 /*SSLProtocol*/
    public open mut prop TLSMinimumSupportedProtocolVersion: Int32 /*tls_protocol_version_t*/
    public open mut prop TLSMaximumSupportedProtocolVersion: Int32 /*tls_protocol_version_t*/
    public open mut prop HTTPShouldUsePipelining: Bool
    public open mut prop HTTPShouldSetCookies: Bool
    public open mut prop HTTPCookieAcceptPolicy: Int32 /*NSHTTPCookieAcceptPolicy*/
    public open mut prop HTTPAdditionalHeaders: ?NSDictionary/*<KeyType, ObjectType>*/
    public open mut prop HTTPMaximumConnectionsPerHost: NSInteger
    public open mut prop HTTPCookieStorage: ?NSHTTPCookieStorage
    public open mut prop URLCredentialStorage: ?NSURLCredentialStorage
    public open mut prop URLCache: ?NSURLCache
    public open mut prop shouldUseExtendedBackgroundIdleMode: Bool
    public open mut prop protocolClasses: ?NSArray/*<Class>*/
    public open mut prop multipathServiceType: Int32 /*NSURLSessionMultipathServiceType*/
    public init()
    public static func new(): NSURLSessionConfiguration
    @ForeignName["backgroundSessionConfiguration:"] public static func backgroundSessionConfiguration(identifier: NSString): NSURLSessionConfiguration
}

public abstract sealed class NSURLSessionDelayedRequestDisposition {
    public static const NSURLSessionDelayedRequestContinueLoading: NSInteger = 0
    public static const NSURLSessionDelayedRequestUseNewRequest: NSInteger = 1
    public static const NSURLSessionDelayedRequestCancel: NSInteger = 2
}

public abstract sealed class NSURLSessionAuthChallengeDisposition {
    public static const NSURLSessionAuthChallengeUseCredential: NSInteger = 0
    public static const NSURLSessionAuthChallengePerformDefaultHandling: NSInteger = 1
    public static const NSURLSessionAuthChallengeCancelAuthenticationChallenge: NSInteger = 2
    public static const NSURLSessionAuthChallengeRejectProtectionSpace: NSInteger = 3
}

public abstract sealed class NSURLSessionResponseDisposition {
    public static const NSURLSessionResponseCancel: NSInteger = 0
    public static const NSURLSessionResponseAllow: NSInteger = 1
    public static const NSURLSessionResponseBecomeDownload: NSInteger = 2
    public static const NSURLSessionResponseBecomeStream: NSInteger = 3
}

@ObjCMirror
public interface NSURLSessionDataDelegate <: NSURLSessionTaskDelegate {
    @ObjCOptional
    @ForeignName["URLSession:dataTask:didReceiveResponse:completionHandler:"] func URLSessionDataTaskDidReceiveResponseCompletionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: ObjCBlock<(Int32 /*NSURLSessionResponseDisposition*/) -> Unit>): Unit
    @ObjCOptional
    @ForeignName["URLSession:dataTask:didBecomeDownloadTask:"] func URLSessionDataTaskDidBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:dataTask:didBecomeStreamTask:"] func URLSessionDataTaskDidBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:dataTask:didReceiveData:"] func URLSessionDataTaskDidReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): Unit
    @ObjCOptional
    @ForeignName["URLSession:dataTask:willCacheResponse:completionHandler:"] func URLSessionDataTaskWillCacheResponseCompletionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: ObjCBlock<(NSCachedURLResponse) -> Unit>): Unit
}

@ObjCMirror
public interface NSURLSessionDownloadDelegate <: NSURLSessionTaskDelegate {
    @ForeignName["URLSession:downloadTask:didFinishDownloadingToURL:"] func URLSessionDownloadTaskDidFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): Unit
    @ObjCOptional
    @ForeignName["URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:"] func URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: int64_t, totalBytesWritten: int64_t, totalBytesExpectedToWrite: int64_t): Unit
    @ObjCOptional
    @ForeignName["URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:"] func URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: int64_t, expectedTotalBytes: int64_t): Unit
}

@ObjCMirror
public interface NSURLSessionStreamDelegate <: NSURLSessionTaskDelegate {
    @ObjCOptional
    @ForeignName["URLSession:readClosedForStreamTask:"] func URLSessionReadClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:writeClosedForStreamTask:"] func URLSessionWriteClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:betterRouteDiscoveredForStreamTask:"] func URLSessionBetterRouteDiscoveredForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): Unit
    @ObjCOptional
    @ForeignName["URLSession:streamTask:didBecomeInputStream:outputStream:"] func URLSessionStreamTaskDidBecomeInputStreamOutputStream(session: NSURLSession, streamTask: NSURLSessionStreamTask, inputStream: NSInputStream, outputStream: NSOutputStream): Unit
}

@ObjCMirror
public interface NSURLSessionWebSocketDelegate <: NSURLSessionTaskDelegate {
    @ObjCOptional
    @ForeignName["URLSession:webSocketTask:didOpenWithProtocol:"] func URLSessionWebSocketTaskDidOpenWithProtocol(session: NSURLSession, webSocketTask: NSURLSessionWebSocketTask, protocol: ?NSString): Unit
    @ObjCOptional
    @ForeignName["URLSession:webSocketTask:didCloseWithCode:reason:"] func URLSessionWebSocketTaskDidCloseWithCodeReason(session: NSURLSession, webSocketTask: NSURLSessionWebSocketTask, closeCode: Int32 /*NSURLSessionWebSocketCloseCode*/, reason: ?NSData): Unit
}

public abstract sealed class NSURLSessionTaskMetricsResourceFetchType {
    public static const NSURLSessionTaskMetricsResourceFetchTypeUnknown: NSInteger = 0
    public static const NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad: NSInteger = 1
    public static const NSURLSessionTaskMetricsResourceFetchTypeServerPush: NSInteger = 2
    public static const NSURLSessionTaskMetricsResourceFetchTypeLocalCache: NSInteger = 3
}

public abstract sealed class NSURLSessionTaskMetricsDomainResolutionProtocol {
    public static const NSURLSessionTaskMetricsDomainResolutionProtocolUnknown: NSInteger = 0
    public static const NSURLSessionTaskMetricsDomainResolutionProtocolUDP: NSInteger = 1
    public static const NSURLSessionTaskMetricsDomainResolutionProtocolTCP: NSInteger = 2
    public static const NSURLSessionTaskMetricsDomainResolutionProtocolTLS: NSInteger = 3
    public static const NSURLSessionTaskMetricsDomainResolutionProtocolHTTPS: NSInteger = 4
}

@ObjCMirror
public open class NSURLSessionTaskTransactionMetrics <: NSObject {
    public open prop request: NSURLRequest
    public open prop response: ?NSURLResponse
    public open prop fetchStartDate: ?NSDate
    public open prop domainLookupStartDate: ?NSDate
    public open prop domainLookupEndDate: ?NSDate
    public open prop connectStartDate: ?NSDate
    public open prop secureConnectionStartDate: ?NSDate
    public open prop secureConnectionEndDate: ?NSDate
    public open prop connectEndDate: ?NSDate
    public open prop requestStartDate: ?NSDate
    public open prop requestEndDate: ?NSDate
    public open prop responseStartDate: ?NSDate
    public open prop responseEndDate: ?NSDate
    public open prop networkProtocolName: ?NSString
    public open prop isProxyConnection: Bool
    public open prop isReusedConnection: Bool
    public open prop resourceFetchType: Int32 /*NSURLSessionTaskMetricsResourceFetchType*/
    public open prop countOfRequestHeaderBytesSent: int64_t
    public open prop countOfRequestBodyBytesSent: int64_t
    public open prop countOfRequestBodyBytesBeforeEncoding: int64_t
    public open prop countOfResponseHeaderBytesReceived: int64_t
    public open prop countOfResponseBodyBytesReceived: int64_t
    public open prop countOfResponseBodyBytesAfterDecoding: int64_t
    public open prop localAddress: ?NSString
    public open prop localPort: ?NSNumber
    public open prop remoteAddress: ?NSString
    public open prop remotePort: ?NSNumber
    public open prop negotiatedTLSProtocolVersion: ?NSNumber
    public open prop negotiatedTLSCipherSuite: ?NSNumber
    public open prop isCellular: Bool
    public open prop isExpensive: Bool
    public open prop isConstrained: Bool
    public open prop isMultipath: Bool
    public open prop domainResolutionProtocol: Int32 /*NSURLSessionTaskMetricsDomainResolutionProtocol*/
    public init()
    public static func new(): NSURLSessionTaskTransactionMetrics
}

@ObjCMirror
public open class NSURLSessionTaskMetrics <: NSObject {
    public open prop transactionMetrics: NSArray/*<NSURLSessionTaskTransactionMetrics>*/
    public open prop taskInterval: NSDateInterval
    public open prop redirectCount: NSUInteger
    public init()
    public static func new(): NSURLSessionTaskMetrics
}

